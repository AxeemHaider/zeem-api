package org.octabyte.zeem.API.Helper;

import com.googlecode.objectify.Key;
import com.googlecode.objectify.Ref;
import org.octabyte.zeem.Datastore.*;
import org.octabyte.zeem.Firebase.PushNotification;
import org.octabyte.zeem.Helper.DataType;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.Function;
import java.util.function.Predicate;

import static org.octabyte.zeem.Helper.OfyService.ofy;

public class Datastore {

    // There maybe some owner id for application alert
    // This is used for application alert
    // A user must be exist with this id
    public static Long ownerId = 111333555777137L;

    /** After 10 years
     * Human time (GMT): Friday, July 7, 2028 7:07:07 AM
     * Human time (your time zone): Friday, July 7, 2028 12:07:07 PM GMT+05:00
     */
    private static Long afterTenYears = 1846566427L;

    /**
     * Auto Generated Long id for datastore using Data and current milli sec
     * @return Long id
     */
    public static Long autoGeneratedId(){

        return afterTenYears - System.currentTimeMillis() / 1000;

    }

    public static <T> Predicate<T> distinctByKey(Function<? super T, ?> keyExtractor) {
        Set<Object> seen = ConcurrentHashMap.newKeySet();
        return t -> seen.add(keyExtractor.apply(t));
    }

    /**
     * Sort array according to Frequency.
     * @param ids   (String) Ids that need to be sort
     * @return      sorted form of array max limit is 200. Unique values
     */
    public static String[] sortArrayByFreq(String ids[]){

        // Set limit not to exceed ids to this range
        int limit = 200; // Only first 200 ids save

        Map<String, Integer> map = new TreeMap<>();

       /* Logic to place the elements to Map */
        for(int i=0; i<ids.length; i++){
            if(map.get(ids[i]) == null){
                map.put(ids[i], 1);
            }
            else{
                int frequency = map.get(ids[i]);
                map.put(ids[i], frequency+1);
            }
        }

        //System.out.println(map);

        List list = new LinkedList(map.entrySet());

       /* Sort the list elements based on frequency */
        Collections.sort(list, (Comparator) (obj1, obj2) -> ((Comparable) ((Map.Entry) (obj2)).getValue())
                .compareTo(((Map.Entry) (obj1)).getValue()));

        int count=0;

       /* Place the elements in to the array based on frequency */
        for (Iterator it = list.iterator(); it.hasNext();) {
            Map.Entry entry = (Map.Entry) it.next();

            if(count <= limit) {
                ids[count] = (String) entry.getKey();
                count++;
            }else{
                break;
            }

            /*
            Long key = (Long)entry.getKey();
            int val = (int)entry.getValue();

            for(int i=0; i < val; i++){
                a[count] = key;
                count++;
            }*/
        }
        return Arrays.stream(ids).distinct().toArray(String[]::new);
    }

    // Over loading function sendPrivateNotification
    public static void sendPrivateNotification(Long receiverId, Long userId, DataType.NotificationType type, String postSafeKey){
        sendPrivateNotification(receiverId, userId, type, postSafeKey, false);
    }

    /**
     * Send Private notification of any type
     * @param receiverId  Id of that user to whom you want to send notification
     * @param userId    Id of that user how perform any action e.g like a post, friend request
     * @param type  Custom Data type for Notification
     * @param postSafeKey    When notification is about post e.g tag post and list post. Otherwise It can be NULL.
     * @param anonymous      Is notification is about to anonymous person
     */
    public static void sendPrivateNotification(Long receiverId, Long userId, DataType.NotificationType type, String postSafeKey, boolean anonymous){

        // Create friend key
        Key<User> friendKey = Key.create(User.class, receiverId);
        // Create user key
        Key<User> userKey = Key.create(User.class, userId);
        // Create auto generated id
        Long notificationId = Datastore.autoGeneratedId();

        // Declare notification
        PrivateNotification notification;

        // Check Notification is about post
        if(postSafeKey != null) { // Notification is about post

            // Send notification to mobile app
            PushNotification.send(receiverId, userId, type, "PRIVATE", postSafeKey, anonymous);

            // Notification constructor with post field
            notification =
                    new PrivateNotification(notificationId, friendKey, Ref.create(userKey), type,
                            Ref.create(Key.create(postSafeKey)), anonymous);

        }else { // Notification is not about post

            // Send notification to mobile app
            PushNotification.send(receiverId, userId, type, "PRIVATE");

            notification =
                    new PrivateNotification(notificationId, friendKey, Ref.create(userKey), type);
        }

        // Add notification
        ofy().save().entity(notification).now();

        // Inform User Alert that something new is coming (Updating)
        Datastore.updateUserAlert(receiverId, notificationId, DataType.Alert.NOTIFICATION, true);
        //Datastore.informPrivateAlert(receiverId, notificationId, DataType.Alert.NOTIFICATION); (REMOVE)
    }

    // Over loading function sendPublicNotification
    public static void sendPublicNotification(Long receiverId, Long userId, DataType.NotificationType type, String postSafeKey){
        sendPublicNotification(receiverId, userId, type, postSafeKey, false);
    }

    /**
     * Send Public notification of any type
     * @param receiverId  Id of that user to whom you want to send notification
     * @param userId    Id of that user how perform any action e.g like a post, friend request
     * @param type  Custom Data type for Notification type
     * @param postSafeKey    When notification is about post e.g tag post and list post. It can be NULL.
     * @param anonymous      Is notification is about to anonymous person
     */
    public static void sendPublicNotification(Long receiverId, Long userId, DataType.NotificationType type, String postSafeKey, boolean anonymous){

        // Create friend key
        Key<User> friendKey = Key.create(User.class, receiverId);
        // Create user key
        Key<User> userKey = Key.create(User.class, userId);
        // Create auto generated id
        Long notificationId = Datastore.autoGeneratedId();

        // Declare notification
        PublicNotification notification;

        // Check Notification is about post
        if(postSafeKey != null) { // Notification is about post

            // Send notification to mobile app
            PushNotification.send(receiverId, userId, type, "PUBLIC", postSafeKey, anonymous);

            // Notification constructor with post field
            notification =
                    new PublicNotification(notificationId, friendKey, Ref.create(userKey), type,
                            Ref.create(Key.create(postSafeKey)), anonymous);

        }else { // Notification is not about post

            // Send notification to mobile app
            PushNotification.send(receiverId, userId, type, "PUBLIC");

            notification =
                    new PublicNotification(notificationId, friendKey, Ref.create(userKey), type);
        }

        // Add notification
        ofy().save().entity(notification).now();

        // Inform User Alert that something new is coming (Updating)
        Datastore.updateUserAlert(receiverId, notificationId, DataType.Alert.NOTIFICATION, false);
        //Datastore.informPublicAlert(receiverId, notificationId, DataType.Alert.NOTIFICATION); (REMOVE)
    }

    // Overloading function - updateUserAlert
    public static void updateUserAlert(Long userId, Long alertId, DataType.Alert type, Boolean isPrivate){
        updateUserAlert(userId, alertId, type, isPrivate, false);
    }
    /**
     * Update User Alert
     * @param userId    Id of the user to which you want to inform
     * @param alertId   which to update in user alert it may be notification last id or feed last id
     * @param type      What you want to reset Notification or Feed
     * @param isPrivate What type of Alert you want to reset Private or Public
     * @param forceMode Set true when you want to force update user alert
     */
    public static void updateUserAlert(Long userId, Long alertId, DataType.Alert type, Boolean isPrivate, Boolean forceMode){
        // Create user alert object
        UserAlert userAlert = (UserAlert) ofy().load().key(Key.create(UserAlert.class, userId)).now();

        // If userAlert is null return back
        if (userAlert == null)
            return;

        // Check what to reset Notification or Feed
        if(type == DataType.Alert.NOTIFICATION) { // Reset Notification

            // Check What notification need to reset Public or Private
            if (isPrivate) { // Reset private notification

                // Check if Notification id if zero than update otherwise leave it OR if alert id is zero means reset this
                if (userAlert.getPrivateNotificationId() == 0 || alertId == 0 || forceMode) { // Update this

                    // Set private notification to alertId for resetting
                    userAlert.setPrivateNotificationId(alertId);
                    // Save update
                    ofy().save().entity(userAlert).now(); // REMOVE-NOW

                }

            }else{ // Reset public notification

                // Check if Feed id if zero than update otherwise leave it OR if alert id is zero means reset this
                if (userAlert.getPublicNotificationId() == 0 || alertId == 0 || forceMode) { // Update this

                    // Set Public notification to alertId for resetting
                    userAlert.setPublicNotificationId(alertId);
                    // Save update
                    ofy().save().entity(userAlert).now(); // REMOVE-NOW

                }

            } // end if-else

        }else{ // Reset Feed

            // Check what feed need to reset public or private
            if(isPrivate) { // Reset private feed

                // Check if Feed id if zero than update otherwise leave it OR if alert id is zero means reset this
                if (userAlert.getPrivateFeedId() == 0 || alertId == 0 || forceMode) { // Update this

                    // Set private feed to alertId for resetting
                    userAlert.setPrivateFeedId(alertId);
                    // Save update
                    ofy().save().entity(userAlert).now(); // REMOVE-NOW
                }

            }else{ // Reset Public feed

                // Check if Feed id if zero than update otherwise leave it OR if alert id is zero means reset this
                if (userAlert.getPublicFeedId() == 0 || alertId == 0 || forceMode) { // Update this

                    // Set public feed to alertId for resetting
                    userAlert.setPublicFeedId(alertId);
                    // save update
                    ofy().save().entity(userAlert).now(); // REMOVE-NOW
                }

            } // end if-else

        } // end if-else

    }

}

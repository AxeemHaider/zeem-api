package org.octabyte.zeem.API;

import com.google.api.server.spi.config.*;
import com.google.appengine.api.taskqueue.Queue;
import com.google.appengine.api.taskqueue.QueueFactory;
import com.google.appengine.api.taskqueue.TaskOptions;
import com.googlecode.objectify.Key;
import com.googlecode.objectify.NotFoundException;
import com.googlecode.objectify.Ref;
import org.octabyte.zeem.API.Entity.FeedItem;
import org.octabyte.zeem.API.Entity.PostFeed;
import org.octabyte.zeem.API.Entity.TaskComplete;
import org.octabyte.zeem.API.Helper.ApiHelper;
import org.octabyte.zeem.API.Helper.Datastore;
import org.octabyte.zeem.API.Helper.UserHelper;
import org.octabyte.zeem.Datastore.*;
import org.octabyte.zeem.Helper.DataType;
import org.octabyte.zeem.Helper.Utils;
import org.octabyte.zeem.Queues.CreateFeed;

import java.util.ArrayList;
import java.util.List;

import static org.octabyte.zeem.Helper.OfyService.ofy;

/**
 * Zeem API version v1 - Defining Account EndPoints
 */
@Api(
        name = "zeem",
        version = "v1",
        apiKeyRequired = AnnotationBoolean.TRUE
)

public class PostApi {


    /**
     * Get a single post, Mostly used in notification
     * @param userId        User who want to get post
     * @param postSafeKey   post safe key
     * @return              Formatted form of post into PostFeed object
     */
    @ApiMethod(path = "getSinglePost/{userId}/{postSafeKey}")
    public PostFeed getSinglePost(@Named("userId") Long userId, @Named("postSafeKey") String postSafeKey){

        // Create PostFeed object
        PostFeed postFeed = new PostFeed();

        try {
            // Get post object with safe mode, if post not found create exception
            Post post = (Post) ofy().load().key(Key.create(postSafeKey)).safe();

            // Create list to hold feedItem in this case it only contain one element
            List<FeedItem> feedItems = new ArrayList<>();

            // Convert post into formatted form of PostFeed
            // Add it into feedItems
            feedItems.add(ApiHelper.FormatUserFeed(userId, post));

            // Set feedItems to postFeed object
            postFeed.setFeedList(feedItems);

        } catch (NotFoundException e) {
            e.printStackTrace();
        }

        return postFeed;
    }

    /**
     * Create Post, Any type of post image, audio, video or GIF
     * @param userId        How is created Post
     * @param tagUserIds    How are tagged with this post
     * @param post          Detail of the Post. (Object)
     * @return              Created Post
     */
    public Post createPost(@Named("userId") Long userId, @Nullable @Named("tagUserId")List<Long> tagUserIds, Post post){

        // Generate post id from time stamp
        post.setPostId(Datastore.autoGeneratedId());

        // Make user as a parent of this post
        post.setUserKey(Key.create(User.class, userId));

        // Check this post is tagged to someone or not
        if ( post.getPostTag() ) { // post is Tagged

            // Set how many user is tagged with this post
            post.setTaggedCount(tagUserIds.size());

            // Create postKey from postId
            Key postKey = Key.create(Post.class, post.getPostId());

            // List of PostTag which hold tagUserIds
            List<PostTag> postTags = new ArrayList<>();

            // Attach each tagUserId with post
            for ( Long tagUserId : tagUserIds ) {

                // Prepare PostTag for batch save
                postTags.add( new PostTag(postKey, tagUserId) );

            }

            // Batch save Tagged user
            ofy().save().entities(postTags).now();

        }

        // save post
        ofy().save().entity(post).now();

        // Setting post safe key, Just pass null it automatically set
        post.setPostSafeKey(null);

        // Increment in user post count
        UserHelper.incrementPostCount(userId);

        // Check post expire Time is set or not
        if (post.getExpireTime() != null) { // Expire time is set

            // Add this post into ExpirePost
            ExpirePost expirePost = new ExpirePost(post.getExpireTime(), post.getPostSafeKey());

            // Save this entity
            ofy().save().entities(expirePost); // Async Task

        }

        // Add Queue (create-post) for creating post and it's feed
        Queue postQueue = QueueFactory.getQueue("create-feed");

        // Check list Post or not
        if (post.getListId() == null) { // Not a list post

            postQueue.add(TaskOptions.Builder.withUrl("/queue/creating_feed")
                    .param("userId", String.valueOf(userId))
                    .param("postId", String.valueOf(post.getPostId()))
                    .param("postTag", String.valueOf(post.getPostTag()))
                    .param("isPublic", String.valueOf(post.getMode()))
                    .param("isAnonymous", String.valueOf(post.getAnonymous()))
            );

        }else { // List post - Add list id with task Queue

            postQueue.add(TaskOptions.Builder.withUrl("/queue/creating_feed")
                    .param("userId", String.valueOf(userId))
                    .param("postId", String.valueOf(post.getPostId()))
                    .param("postTag", String.valueOf(post.getPostTag()))
                    .param("listId", post.getListId())
                    .param("isPublic", String.valueOf(post.getMode()))
                    .param("isAnonymous", String.valueOf(post.getAnonymous()))
            );

        }

        return post;
    }

    /**
     * Delete post
     * @param postSafeKey   Safe key of the post that you want to delete
     */
    public void deletePost(@Named("postSafeKey") String postSafeKey){

        // Create postKey from safeKey
        Key<Post> postKey = Key.create(postSafeKey);

        // Delete this post
        ofy().delete().key(postKey);

    }

    /**
     * Get users that are tagged with the post
     * @param postId    Id of post which you want to get tagged user
     * @return          List of User that are tagged with this post
     */
    @ApiMethod(path = "getTaggedUser/{postId}")
    public List<User> getTaggedUser(@Named("postId") Long postId){

        // Create postKey from postId
        Key postKey = Key.create(Post.class, postId);

        // Get tagged user from this post
        List<PostTag> postTags = ofy().load().type(PostTag.class).ancestor(postKey).list();

        // Check there is some post tags or not
        if (postTags.size() > 0) { // There is some users tagged with this post

            // Create key list to hold user Keys, those user keys which are tagged with this post
            List<Key<User>> userKeys = new ArrayList<>();

            // Loop each user
            for (PostTag postTag : postTags) {

                // convert user Ids into user Keys and save it in userKeys list for batch load
                userKeys.add(Key.create(User.class, postTag.getUserId()));

            } // end for loop

            // Get all users with userKeys list and return it
            return ofy().load().type(User.class).filterKey("in", userKeys).list();
        }

        return null;
    }

    /**
     * Like a post (Post Star)
     * @param userId        Who like(Star) the post
     * @param postSafeKey   Post safe key where like(Star) is hit
     */
    public void postStar(@Named("userId") Long userId, @Named("postSafeKey") String postSafeKey){

        // Create postKey from postSafeKey
        Key<Post> postKey = Key.create(postSafeKey);

        try {
            // increment in post star count
            // Get Post that need to update
            Post post = (Post) ofy().load().key(postKey).safe();
            post.setStarCount( post.getStarCount() + 1 ); // Update starCount - increment one
            // Save and update this post
            ofy().save().entity(post); // Async Task

            // Create userKey from userId
            Key<User> userKey = Key.create(User.class, userId);

            // Create PostStar object and save it
            PostStar postStar = new PostStar(Datastore.autoGeneratedId(), userKey, postSafeKey);
            postStar.setUserId(userId);
            ofy().save().entity(postStar); // Async Task

            // Increment in user star
            UserHelper.incrementUserStar(post.getUserKey().getId());

            // Send  notification to the owner of this post
            // Check post mode
            if (post.getMode() == DataType.Mode.PRIVATE) { // Post is private
                // Send Private notification
                Datastore.sendPrivateNotification(post.getUserKey().getId(), userId, DataType.NotificationType.POST_LIKE, postSafeKey);
            }else{ // Post is public
                // Send Public notification
                Datastore.sendPublicNotification(post.getUserKey().getId(), userId, DataType.NotificationType.POST_LIKE, postSafeKey);
            } // end if-else

        } catch (NotFoundException e) {
            e.printStackTrace();
        }

    }

    /**
     * Get all user who liked(star) this post
     * @param postSafeKey    safe key of post which want to get post star
     * @return          list of user who liked(star) post
     */
    public List<User> getPostStar(@Named("postSafeKey") String postSafeKey){

        // Load 30 users who liked this post
        List<PostStar> postStars = ofy().load().type(PostStar.class).filter("postSafeKey", postSafeKey).limit(30).list();

        // Create key list to hold user Keys
        List<Key<User>> userKeys = new ArrayList<>();

        // loop each post star
        for( PostStar postStar : postStars ){
            // convert user Ids into user Keys and save it in userKeys list
            userKeys.add(postStar.getUserKey());
        } // end for-loop

        // Check some user star this post or not
        if (userKeys.size() > 0) { // Some user start this post
            // Get all users with userKeys list and return it
            return ofy().load().type(User.class).filterKey("in", userKeys).list();
        }

        return null;
    }

    /**
     * Save any post for user
     * @param userId        Who want to save post
     * @param postSafeKey   post safe key which need to be save
     * @return              Task complete TRUE
     */
    public TaskComplete savePost(@Named("userId") Long userId, @Named("postSafeKey") String postSafeKey){

        // Create new SavedPost object
        SavedPost savedPost = new SavedPost(Datastore.autoGeneratedId(), Key.create(User.class, userId), Ref.create(Key.create(postSafeKey)));

        // Save this post
        ofy().save().entity(savedPost); // Async Task

        return new TaskComplete(true);
    }

    /**
     * Approved Tag (Approval will be according to setting)
     * @param userId    Who want to approve Tag
     * @param postId    Which post need to approve it postId not safeKey
     * @param isPublic  Post mode is public or private
     */
    public void tagApproved(@Named("userId") Long userId, @Named("postId") Long postId, @Named("isPublic") Boolean isPublic){

        // Approved post (Approval will be according to setting)
        CreateFeed.approveTagForThisUser(userId, postId, null, isPublic, true, null);

        // Now get all tagged user and find my user id from them and set tag is approved for me

        // Create postKey from postId
        Key postKey = Key.create(Post.class, postId);

        // Get tagged user from this post
        List<PostTag> postTags = ofy().load().type(PostTag.class).ancestor(postKey).list();

        // Loop each postTag
        for (PostTag postTag : postTags){

            // Match my id with post tag user id
            if (userId.equals(postTag.getUserId())){ // Id matched
                // Set tag approved for me
                postTag.setTagApproved(true);
                break; // end the loop
            }

        } // end loop

    }

    /**
     * Report to any post
     * @param userId        id of user how report the post
     * @param postSafeKey   post safe key that for post reported
     * @param reportType    what violation did this post
     */
    public void report(@Named("userId") Long userId, @Named("postSafeKey") String postSafeKey, @Named("reportType") DataType.Report reportType){

        // Convert postSafeKey into postKey
        Key<Post> postKey = Key.create(postSafeKey);

        // Get Post Object first
        Post post = (Post) ofy().load().key(postKey).now();

        // Check already reported this post or not
        PostReport postReport = (PostReport) ofy().load().key(Key.create(PostReport.class, postKey.getId())).now();

        if(postReport != null) { // this post is already reported

            // Check if count is enough(7) then delete this post
            if (postReport.getReportCount() >= 2) { // Delete this post

                String postContent = "userId:"+post.getUserKey().getId();
                        postContent += ",mode:"+post.getMode();
                        postContent += ",type:"+post.getType();
                        postContent += ",caption:"+post.getCaption();
                        postContent += ",cover:"+post.getCover();
                        postContent += ",soruce:"+post.getSource();

                ofy().save().entity(new PostBlocked(postContent)); // Async Task
                // Delete post
                ofy().delete().key(postKey); // Async Task

                // inform user about this
                // Check post is private or public
                if (post.getMode() == DataType.Mode.PRIVATE) // Post is private
                    Datastore.sendPrivateNotification(postKey.getParent().getId(), Datastore.ownerId, DataType.NotificationType.POST_DELETE, null);
                else // Post is public
                    Datastore.sendPublicNotification(postKey.getParent().getId(), Datastore.ownerId, DataType.NotificationType.POST_DELETE, null);

                // Check user is already in violated user list
                ViolatedUser violatedUser = ofy().load().key(Key.create(ViolatedUser.class, postKey.getParent().getId())).now();
                if(violatedUser != null) { // User is already in violation list
                    // increase violation count
                    violatedUser.setViolationCount( violatedUser.getViolationCount() + 1 );
                    ofy().save().entity(violatedUser); // Async Task
                } else { // First time user violate the terms
                    // Add user into violated list
                    ofy().save().entity(new ViolatedUser(postKey.getParent().getId())); // Async Task
                } // end inner if-else

            } else {
                // increase the report count
                postReport.setReportCount( postReport.getReportCount() + 1 );

                // Get User List and Add user into it
                List<Long> userList = postReport.getUserIds();
                if(userList == null) {
                    userList = new ArrayList<>();
                }
                userList.add(userId);
                // Save into object
                postReport.setUserIds(userList);

                //Get reportType list and add this report type into it
                List<DataType.Report> reports = postReport.getReportTypes();
                if(reports == null) {
                    reports = new ArrayList<>();
                }
                reports.add(reportType);
                // Save into object
                postReport.setReportTypes(reports);

                // Save and update
                ofy().save().entity(postReport); // Async Task

                // Create variable to hold notification type according to report type
                DataType.NotificationType notificationType = DataType.NotificationType.REPORT_OTHER;
                // Check what kind of this report type
                switch (reportType){
                    case SPAM:
                        notificationType = DataType.NotificationType.REPORT_SPAM;
                        break;
                    case ANTI_RELIGION:
                        notificationType = DataType.NotificationType.REPORT_ANTI_RELIGION;
                        break;
                    case SEXUAL_CONTENT:
                        notificationType = DataType.NotificationType.REPORT_SEXUAL_CONTENT;
                        break;
                }

                // inform user about this
                // Check post is private or public
                if (post.getMode() == DataType.Mode.PRIVATE) // Post is private
                    Datastore.sendPrivateNotification(postKey.getParent().getId(), Datastore.ownerId, notificationType, postSafeKey);
                else // Post is public
                    Datastore.sendPublicNotification(postKey.getParent().getId(), Datastore.ownerId, notificationType, postSafeKey);


            } // end inner if-else

        } else { // It's first time when reporting about this post
            // Create new post report
            PostReport postReport1 = new PostReport(postKey.getId());

            // Create userList
            List<Long> userList = new ArrayList<>();
            userList.add(userId);
            // Save into object
            postReport1.setUserIds(userList);

            // Create report type list
            List<DataType.Report> reports = new ArrayList<>();
            reports.add(reportType);
            // save into object
            postReport1.setReportTypes(reports);

            // Save it
            ofy().save().entity(postReport1); // Async Task

            // Create variable to hold notification type according to report type
            DataType.NotificationType notificationType = DataType.NotificationType.REPORT_OTHER;
            // Check what kind of this report type
            switch (reportType){
                case SPAM:
                    notificationType = DataType.NotificationType.REPORT_SPAM;
                    break;
                case ANTI_RELIGION:
                    notificationType = DataType.NotificationType.REPORT_ANTI_RELIGION;
                    break;
                case SEXUAL_CONTENT:
                    notificationType = DataType.NotificationType.REPORT_SEXUAL_CONTENT;
                    break;
            }

            // inform user about this
            // Check post is private or public
            if (post.getMode() == DataType.Mode.PRIVATE) // Post is private
                Datastore.sendPrivateNotification(postKey.getParent().getId(), Datastore.ownerId, notificationType, postSafeKey);
            else // Post is public
                Datastore.sendPublicNotification(postKey.getParent().getId(), Datastore.ownerId, notificationType, postSafeKey);


        } // end if-else

    }

}

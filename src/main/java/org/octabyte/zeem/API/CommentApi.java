package org.octabyte.zeem.API;

import com.google.api.server.spi.config.AnnotationBoolean;
import com.google.api.server.spi.config.Api;
import com.google.api.server.spi.config.Named;
import com.google.api.server.spi.config.Nullable;
import com.google.appengine.api.datastore.Cursor;
import com.google.appengine.api.datastore.QueryResultIterator;
import com.google.appengine.api.taskqueue.Queue;
import com.google.appengine.api.taskqueue.QueueFactory;
import com.google.appengine.api.taskqueue.TaskOptions;
import com.googlecode.objectify.Key;
import com.googlecode.objectify.Ref;
import com.googlecode.objectify.cmd.Query;
import org.octabyte.zeem.API.Entity.CommentResponse;
import org.octabyte.zeem.API.Helper.ApiHelper;
import org.octabyte.zeem.API.Helper.Datastore;
import org.octabyte.zeem.API.Helper.UserHelper;
import org.octabyte.zeem.Datastore.Comment;
import org.octabyte.zeem.Datastore.Post;
import org.octabyte.zeem.Datastore.User;
import org.octabyte.zeem.Helper.DataType;
import org.octabyte.zeem.Helper.Utils;

import java.util.ArrayList;
import java.util.List;

import static org.octabyte.zeem.Helper.OfyService.ofy;

/**
 * Zeem API version v1 - Defining User EndPoints
 */
@Api(
        name = "zeem",
        version = "v1",
        apiKeyRequired = AnnotationBoolean.TRUE
)

public class CommentApi {

    /**
     * Get post comments
     * @param userId    Id of user who want to get the comments, used for checking comment is liked by me or not
     * @param postId   Post id
     * @param cursor    Cursor where to start next query, It can be null
     * @return         List of comments formatted into CommentResponse
     */
    public CommentResponse getComments(@Named("userId") Long userId, @Named("postId") Long postId,
                                       @Nullable @Named("cursor") String cursor){

        // Create a new CommentResponse object
        CommentResponse commentResponse = new CommentResponse();

        // Create a list to hold comment
        List<Comment> commentList = new ArrayList<>();

        // Get last 30 comments of this Post
        Query<Comment> commentQuery = ofy().load().type(Comment.class).ancestor(Key.create(Post.class, postId)).limit(30);

        // If cursor is set then start query from cursor
        if (cursor != null)
            commentQuery = commentQuery.startAt(Cursor.fromWebSafeString(cursor));

        // Create variable to check there are more item or not
        boolean moreItem = false;

        // Create iterator to loop query
        QueryResultIterator<Comment> iterator = commentQuery.iterator();

        // Loop query and convert into list
        while (iterator.hasNext()){
            commentList.add(iterator.next());
            moreItem = true;
        }

        // If there is more items get the cursor
        if (moreItem)
            commentResponse.setCursor(iterator.getCursor().toWebSafeString());

        // Generate Formatted CommentResponse list and return
        if (commentList.size() > 0)
             commentResponse.setCommentList(ApiHelper.generatePostComment(commentList, userId));

        return commentResponse;
    }

    /**
     * Create new comment on this Post
     * @param userId        How is creating comment
     * @param postSafeKey   key of post with user Parent for which comment is created
     * @param comment       Comment object
     * @return              return a comment object
     */
    public Comment postComment(@Named("userId") Long userId, @Named("postSafeKey") String postSafeKey, Comment comment){

        // Convert postSafeKey into postKey to Get post key without user parent from postSafeKey
        Key<Post> postKey = Key.create(postSafeKey);

        // Create new instance of comment
        Comment commentInstance = new Comment(
                Datastore.autoGeneratedId(),
                Key.create(Post.class, postKey.getId()),
                Ref.create(Key.create(User.class, userId)),
                comment.getType(),
                comment.getSource(),
                comment.getAnonymous(),
                comment.getTaggedUser()
        );

        // Save comment instance Async
        ofy().save().entity(commentInstance).now();

        // Start Task Queue to perform comment function like send notification and tag users
        Queue commentQueue = QueueFactory.getQueue("create-comment");
        commentQueue.add(TaskOptions.Builder.withUrl("/queue/creating_comment")
                .param("userId", String.valueOf(userId))
                .param("commentSafeKey", commentInstance.getCommnetSafeKey())
                .param("postSafeKey", postSafeKey)
        );

        return commentInstance;
    }

    /**
     * Like(Star) a comment
     * @param userId            Who like the comment
     * @param commentSafeKey    Comment safe key generated with Post parent
     * @param mode              Post Mode. Require for sending Notification
     */
    public void commentStar(@Named("userId") Long userId, @Named("commentSafeKey") String commentSafeKey, @Named("postMode") DataType.Mode mode){

        // Get comment object from commentSafeKey
        Comment comment = (Comment) ofy().load().key(Key.create(commentSafeKey)).now();
        // Update comment
        comment.setStarCount( comment.getStarCount() + 1 ); // increment star count

        // Create a list to hold commentStarList
        List<Long> commentStarList = new ArrayList<>();

        // Check if there is already some user added in star list for comment
        if(comment.getCommentStar() != null) // There is already some user
            commentStarList = comment.getCommentStar();

        // Add this user into commentStarList
        commentStarList.add(userId);

        // Set star List in comment
        comment.setCommentStar(commentStarList);

        // Save and update comment
        ofy().save().entity(comment); // Async way

        // Inform user (how created this comment) about this like
        // Get userId from this comment
        Long createrId = comment.getUserRef().get().getUserId();

        // Check post mode
        if (mode == DataType.Mode.PRIVATE) { // Post is private
            // Send Private notification
            Datastore.sendPrivateNotification(createrId, userId, DataType.NotificationType.COMMENT_LIKE, null);
        }else{ // Post is public
            // Send Public notification
            Datastore.sendPublicNotification(createrId, userId, DataType.NotificationType.COMMENT_LIKE, null);
        } // end if-else

        // Increment user star
        UserHelper.incrementUserStar(createrId);

    }

    /**
     * Delete comment
     * @param commentSafeKey    commentSafeKey that you want to delete
     */
    public void deleteComment(@Named("commentSafeKey") String commentSafeKey){
        // Delete this comment
        ofy().delete().key(Key.create(commentSafeKey)); // Async Task
    }
}
